#!/usr/bin/python

# Copyright (C) 2017-2018 NEC Corporation
# This file is part of VE system initialization
#
# VE system initialization is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# VE system initialization is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public
# License along with VE system initialization; if not, see
# <http://www.gnu.org/licenses/>

'''
This module monitors os_state for VE node.

Copyright (C) 2017-2018 NEC Corporation
'''
# TODO: create a base class and derive VENode and OSStateMon from it.
import sys
import io
import os
import errno
import syslog
import select
import signal
import stat
import syslog
from syslog import LOG_ERR, LOG_INFO, LOG_DEBUG, LOG_PID, LOG_DAEMON
import pyudev
import subprocess
import glob
from venodectl.signalchannel import SignalChannel

def _debug(msg):
    syslog.syslog(LOG_DEBUG, msg)

class OSStateMon(object):
    '''OS state monitor

    Monitors the os_state file and invokes commands as the state.
    '''

    VE_DEV_FMT = '/dev/veslot%d'
    @property
    def devicefile(self):
        return self.VE_DEV_FMT % self._veno

    # constant defined in VE driver header ve_drv.h
    OS_ST_ONLINE = 0
    OS_ST_OFFLINE = 1
    OS_ST_INITIALIZING = 2
    OS_ST_TERMINATING = 3
    _OS_STATE_STR = ["ONLINE", "OFFLINE", "INITIALIZING", "TERMINATING"]
    @classmethod
    def OS_STATE(cls, os_state):
        return cls._OS_STATE_STR[os_state]

    def _log(self, msg, prio=LOG_INFO):
        '''Output a message with specified priority.'''
        out = "[osstatemon#%d] %s" % (self._veno, msg)
        syslog.syslog(prio, out)

    def __init__(self, veno, options_dirs):
        '''Constructor.
           veno: VE node number to monitor
           options_dirs: a list of directories holding commands to be executed.
        '''
        self._veno = veno
        ctx = pyudev.Context()
        # hold the device file to prevent VE driver from being unload.
        self._devfile = io.open(self.devicefile)
        self._device = pyudev.Device.from_device_file(ctx, self.devicefile)
        self._osstate_file = io.open(self._device.sys_path + '/os_state')
        self.sigchan = SignalChannel([], [signal.SIGINT, signal.SIGTERM], \
                           lambda msg: self._log(msg, LOG_DEBUG))
        self._options_dirs = options_dirs

    @property
    def commands(self):
        return load_commands_from_dirs(self._options_dirs)

    @property
    def os_state(self):
        '''Read os_state.'''
        self._osstate_file.seek(0, io.SEEK_SET)
        s = int(self._osstate_file.read())
        self._log("os_state = %s (%d)" % (self.OS_STATE(s), s), LOG_DEBUG)
        return s

    def try_exec(self, exefile, arg):
        try:
            args = [exefile, str(self._veno), arg]
            self._log("execute: %s" % str(args), LOG_DEBUG)
            rv = subprocess.call(args)
            if rv != 0:
                level = LOG_INFO
            else:
                level = LOG_DEBUG
            self._log("exit %d: %s" % (rv, str(args)), level)
        except OSError as e:
            self._log(exefile + ': ' + e.strerror, LOG_ERR)

    def on_online(self):
        for x in self.commands:
            self.try_exec(x, 'online')

    def on_offline(self):
        for x in self.commands:
            self.try_exec(x, 'offline')

    def handle_event(self):
        try:
            (rlist, wlist, elist) = select.select([self.sigchan], [], \
                                                  [self._osstate_file])
        except select.error as e:
            if e[0] != errno.EINTR:
                raise
            return False
        if self._osstate_file in elist:
            state = self.os_state
            if state == self.OS_ST_ONLINE:
                self.on_online()
            elif state == self.OS_ST_OFFLINE:
                self.on_offline()
        if self.sigchan in rlist:
            signum = self.sigchan.recv()
            assert(signum == signal.SIGINT or signum == signal.SIGTERM)
            return False
        return True

    def start(self):
        while self.handle_event():
            pass
        sys.exit(0)

def load_commands_from_dirs(dirlist):
    '''Load a list of commands on events'''
    retval = []
    for d in dirlist:
        retval.extend(sorted([f for f in glob.iglob(d + '/*') \
                         if os.path.isfile(f) and os.access(f, os.X_OK)]))
    return retval

### start-up routine
def start(ve_no, dirs):
    syslog.openlog(logoption = LOG_PID, facility = LOG_DAEMON)
    _debug(str(sys.argv))
    mon = OSStateMon(ve_no, dirs)
    mon.start()
