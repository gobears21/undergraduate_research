#!/usr/bin/python

# Copyright (C) 2017-2018 NEC Corporation
# This file is part of VE system initialization
#
# VE system initialization is free software; you can redistribute it and/or 
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# VE system initialization is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public
# License along with VE system initialization; if not, see
# <http://www.gnu.org/licenses/>

'''
This module controls VE OS process and os_state for VE node.

Copyright (C) 2017-2018 NEC Corporation
'''
import sys
import io
import os
import syslog
import select
from signal import SIGCHLD, SIGTERM, SIGINT
from syslog import openlog, syslog, LOG_ERR, LOG_INFO, LOG_DEBUG, \
                   LOG_PID, LOG_DAEMON
import errno
import pyudev
import subprocess
import fnmatch
import glob
import shlex
import dbus

from .signalchannel import SignalChannel

VE_DEV_FMT = '/dev/veslot%d'

def _debug(msg):
    syslog(LOG_DEBUG, msg)

class VENode(object):
    '''VE node object

    Holds the path to the device file, sysfs files, VEOS process, etc.

    Attributes:
        _veno: VE number
        _file: stream for ve_state
        _device: device information of a VE node from udev
        _state: the state of the VE node; VE_ST_UNINITIALIZED,
                VE_ST_ONLINE, VE_ST_OFFLINE, VE_ST_MAINTAINANCE or
                VE_ST_UNAVAILABLE.
        osproc: process of VE OS daemon serving this VE node.
                None when VE OS daemon is not running.
        sigchan: signal channel
    '''

    # constants defined in VE driver header ve_drv.h
    VE_ST_UNINITIALIZED = 0
    VE_ST_ONLINE = 1
    VE_ST_OFFLINE = 2
    VE_ST_MAINTAINANCE = 3
    VE_ST_UNAVAILABLE = 4
    _VE_STATE_STR = ["UNINITIALIZED", "ONLINE", "OFFLINE", \
                     "MAINTAINANCE", "UNAVAILABLE"]
    @classmethod
    def VE_STATE(cls, ve_state):
      return cls._VE_STATE_STR[ve_state]

    OS_ST_ONLINE = 0
    OS_ST_OFFLINE = 1
    OS_ST_INITIALIZING = 2
    OS_ST_TERMINATING = 3
    _OS_STATE_STR = ["ONLINE", "OFFLINE", "INITIALIZING", "TERMINATING"]
    @classmethod
    def OS_STATE(cls, os_state):
        return cls._OS_STATE_STR[os_state]

    # time in second
    VEOS_TERM_TIMEOUT = 30
    VEOS_CLEANUP_TIMEOUT = 20

    @property
    def devicefile(self):
        return VE_DEV_FMT % self._veno

    @property
    def extra_args(self):
        return [arg for (servicename, option) in self._options.items() \
                    if check_service_is_active(servicename) for arg in option]

    def __init__(self, veno, veosbin, veos_sock, options_dirs):
        '''Constructor.
           veno: VE node number to serve.
           veosbin: a path to VE OS daemon
           veos_sock: VE OS socket name
           options_dirs: a list of directories to find config files
                         for options to VE OS
        '''
        self._veno = veno
        self._veosbin= veosbin
        self._veos_socket = veos_sock
        ctx = pyudev.Context()
        self._log('open VE node %s' % self.devicefile)
        # hold the device file to prevent VE driver from being unload.
        self._devfile = io.open(self.devicefile)
        self._device = pyudev.Device.from_device_file(ctx, self.devicefile)
        self._file = io.open(self._device.sys_path + '/ve_state')
        self._osstate_filename = self._device.sys_path + '/os_state'
        self._state = self.VE_ST_UNINITIALIZED
        self.osproc = None
        self.sigchan = SignalChannel([SIGCHLD], [SIGINT, SIGTERM], \
                           lambda msg: self._log(msg, LOG_DEBUG))
        self._options = load_option_dirs(options_dirs)

    def _log(self, msg, prio=LOG_INFO):
        '''Output a message with specified priority.'''
        out="[launcher#%d] %s" % (self._veno, msg)
        syslog(prio, out)

    def _update_os_state(self, newstate):
        self._log('set os_state to %s (%d)' % \
                  (self.OS_STATE(newstate), newstate))
        with io.open(self._osstate_filename, 'wb') as f:
            if sys.version_info[0] > 2:
                f.write(str(newstate).encode('utf-8'))
            else:
                f.write(str(newstate))
    def read_os_state(self):
        with io.open(self._osstate_filename, 'rb') as f:
            s = int(f.read())
            self._log("os_state = %s (%d)" % (self.OS_STATE(s), s))
            return s

    @property
    def veos_args(self):
        return [self._veosbin, '-s', self._veos_socket,
                '-d', self.devicefile] + self.extra_args

    def start_veos(self):
        '''Start a VE OS daemon process.'''
        self._log("start VEOS")
        assert(self.osproc == None)
        self.osproc = subprocess.Popen(self.veos_args)

    def read_state(self):
        '''Read ve_state and update _state.'''
        self._file.seek(0, io.SEEK_SET)
        s = int(self._file.read())
        self._state = s
        self._log("ve_state = %s (%d)" % (self.VE_STATE(s), s), LOG_DEBUG)
        return self._state

    def set_os_offline(self):
        '''Set OS state to OFFLINE.'''
        os_state = self.read_os_state()
        if os_state == VENode.OS_ST_ONLINE:
          self._update_os_state(VENode.OS_ST_TERMINATING)
          self._update_os_state(VENode.OS_ST_OFFLINE)
        elif os_state == VENode.OS_ST_OFFLINE:
          self._log("os_state is already OFFLINE.", LOG_DEBUG)
        else:
          self._update_os_state(VENode.OS_ST_OFFLINE)

    def do_cleanup(self):
        '''Clean up for recovery.
           Invoke VE OS with the --cleanup option and wait for completion.
        '''
        self._log("Clean up VE")
        self.osproc = subprocess.Popen(self.veos_args + ['--cleanup'])
        if self.wait_for_SIGCHLD_or_timeout(self.VEOS_CLEANUP_TIMEOUT):
            self.osproc.wait()
            self._log('Clean-up is finished.')
        else:
            self._log('Clean-up time-out expired.')
            self.osproc.kill()
            while not self.wait_for_SIGCHLD_or_timeout(self.VEOS_TERM_TIMEOUT):
                self._log('SIGCHLD has not been delivered yet.')
            self.osproc.wait()

    def wait_for_OFFLINE_ONLINE_nosignal(self):
        '''Wait for VE state set to OFFLINE or ONLINE without handling signals
        '''
        while True:
            vestate = self.read_state()
            if vestate == self.VE_ST_OFFLINE or vestate == self.VE_ST_ONLINE:
                break
            try:
                (rlist, wlist, elist) = select.select([], [], [self._file])
            except select.error as e:
                if e[0] != errno.EINTR:
                    raise

    def finalize_veos(self):
        '''Wait for termination of VE OS daemon process.
           A caller exits after catching termination of VE OS with
           the exit status of VE OS daemon.
           This method never returns.
        '''
        # SIGCHLD state here
        self._log('Finalize VE OS', LOG_DEBUG)
        assert(self.osproc)
        status = self.osproc.wait()
        self.osproc = None
        if status != 0:
            self._log("VE OS exited abnormally (%d)" % status)
            ve_state = self.read_state()
            self._log("ve_state = %s (%d)" % \
                      (self.VE_STATE(ve_state), ve_state))
            if ve_state == VENode.VE_ST_UNAVAILABLE:
              # SIGCHLD -> RECOVERY
              self._log("VE node is UNAVAILABLE; wait for recovery.")
              self.recover()
              # SIGCHLD -> NOTSTARTED
              sys.exit(status)
            # cleanup: SIGCHLD -> CLEANUP
            self._log("transition to the TERMINATING os state.")
            os_state = self.read_os_state()
            if os_state == VENode.OS_ST_INITIALIZING:
                self._log("INITIALIZING state; leave it.")
            elif os_state == VENode.OS_ST_ONLINE:
                self._update_os_state(VENode.OS_ST_TERMINATING)
            elif os_state == VENode.OS_ST_TERMINATING:
                self._log("Already TERMINATING state")
                pass
            elif os_state == VENode.OS_ST_OFFLINE:
                self._log("OFFLINE state; set to INITIALIZING for cleanup.")
                self._update_os_state(VENode.OS_ST_INITIALIZING)
            else:
                self._log("Unexpected OS state (%d)" % os_state)

            self.do_cleanup()
            self._log("transition to the OFFLINE os state")
            self.set_os_offline()
            # CLEANUP -> NOTSTARTED
        else:
            self._log("VE OS exited normally.")
            # READY / TERMINATING -> NOTSTARTED
        sys.exit(status)

    def test_SIGCHLD(self):
        '''Test signals received.
           If SIGCHLD has been caught, obtain the exit status and exit.
           If a caught signal is not SIGCHLD, ignore simply.
        '''
        self._log('Test SIGCHLD', LOG_DEBUG)
        return SIGCHLD in self.sigchan.recv_all()

    def wait_for_SIGCHLD_or_timeout(self, timo):
        '''Wait for SIGCHLD or time-out period.
           Return True upon SIGCHLD; False upon timeout.
        '''
        self._log('wait for a signal.')
        return self.sigchan.wait_for([SIGCHLD], timo)

    def terminate_veos(self):
        '''Terminate VE OS daemon process.
           This method requests VE OS to exit by sending a signal, and
           wait for its termination.
        '''
        # WAIT_VEONLINE or READY
        self._log("terminate VE OS")
        if not self.osproc:
            # WAIT_VEONLINE -> NOTSTARTED; not READY yet.
            self._log("VE OS is not running.")
            sys.exit(0)

        # READY here.
        if self.test_SIGCHLD():
            # VE OS has been dead already.
            # READY -> SIGCHLD
            self.finalize_veos()

        # READY -> TERMINATING
        self.osproc.terminate()
        # wait for a signal message
        # SIGTERM and SIGINT are ignored here and all messages are
        # drained at test_SIGCHLD() before terminating VE OS.
        # Hence, only a SIGCHLD message can be put in signal channel here;
        # we need not consider SIGTERM or SIGINT cases.
        if self.wait_for_SIGCHLD_or_timeout(self.VEOS_TERM_TIMEOUT):
            # TERMINATING -> SIGCHLD
            self.finalize_veos()

        self._log('Terminate VE OS immediately.')
        
        assert(self.osproc)
        # VE OS is still alive.
        self.osproc.kill()
        # TERMINATING -> SIGCHLD
        while not self.wait_for_SIGCHLD_or_timeout(self.VEOS_TERM_TIMEOUT):
          self._log('SIGCHLD has not been delivered yet.')
        self.finalize_veos()

    def recover(self):
        '''Recover from UNAVAILABLE.
        '''
        # set os_state to OFFLINE
        self.set_os_offline()
        # wait for ve_state set to OFFLINE
        self._log("Wait for VE node set to OFFLINE or ONLINE")
        # Since ve_state can be changed to ONLINE before OS launcher
        # completes read() call, OS launcher needs to start do_cleanup()
        # also on VE_ST_ONLINE.
        self.wait_for_OFFLINE_ONLINE_nosignal()
        self.do_cleanup()

    def wait_for_event(self, cond, action):
        '''Wait for an event, change in ve_state or a signal.
           Arguments:
              cond: the condition; wait until cond(ve_state) becomes true.
              action: an action to perform in the condition; when
                     cond(ve_state) is true, actiion() is executed.
           Returns:
              True when the caller event loop should be finished.
              False when the caller need to wait for an event again,
              i.e. the event loop should not be finished.
        '''
        try:
            (rlist, wlist, elist) = select.select([self.sigchan], [], \
                                                  [self._file])
        except select.error as e:
            if e[0] != errno.EINTR:
                raise
            # if a signal interrupted select(), the next select() call
            # will return immediately since signal channel is readable.
            return False

        if self.sigchan in rlist:
            # It is enough to receive a single signal because
            # handlers for signals below terminate OS launcher.
            signum = self.sigchan.recv()
            {
                SIGCHLD: self.finalize_veos,
                SIGINT: self.terminate_veos,
                SIGTERM: self.terminate_veos,
            }[signum]()
        if self._file in elist:
            self.read_state()
            if cond(self._state):
                action()
                return True
        else:
            return False

    def loop_waiting_for_state(self, cond, action):
        '''Wait for a condition specified by cond.
           cond: the condition; wait until cond(ve_state) becomes true.
           action: an action to perform in the condition; when
                   cond(ve_state) is true, actiion() is executed.
        '''
        while not self.wait_for_event(cond, action): pass

    def start(self):
        '''Start VE OS launcher.'''
        # start with WAIT_VEONLINE
        self._log("start", LOG_DEBUG)
        assert(self.osproc == None)
        # check os_state
        os_state = self.read_os_state()
        if os_state != self.OS_ST_OFFLINE:
            self._log("WARNING: os_state is not OFFLINE (%s (%d))" % \
                (self.OS_STATE(os_state), os_state))
            self.set_os_offline()
        # WAIT_VEONLINE -> READY
        self.loop_waiting_for_state(lambda x: x == self.VE_ST_ONLINE, \
                                    self.start_veos)
        # READY -> TERMINATING or SIGCHLD state
        self.loop_waiting_for_state(lambda x: x != self.VE_ST_ONLINE, \
                                    self.terminate_veos)

def check_service_is_active(servname):
    '''Query status of a specified service to systemd.
       Returns true value upon active status.
       servname: service (unit) name
    '''
    _debug('check_service_is_active(%s)' % servname)
    retval = False
    bus = dbus.SystemBus()
    systemd1 = 'org.freedesktop.systemd1'
    sd = bus.get_object(systemd1, '/org/freedesktop/systemd1')
    try:
        allunits = sd.ListUnits(dbus_interface=systemd1+'.Manager')
        # ListUnit returns an array with all currently loaded units:
        # a list of (name, description, load-state, active-state, ...).
        units = [(str(u[0]), str(u[3])) for u in allunits \
                              if fnmatch.fnmatch(u[0], servname)]
        _debug(str(units))
        n = sum(1 for u in units if u[1] == 'active')
        retval = n > 0
    except dbus.exceptions.DBusException as e:
        _debug('failed due to DBusException: [' + str(e) + ']')
        
    return retval

def load_option_file(fname, argsdict):
    '''Load extra arguments from a config file.
       fname: the name of a config file
       argsdict: the dictionary of service names and options to be updated
       return: the updated dictionary
    '''
    _debug('load_extra_args_file: load ' + fname)
    with io.open(fname) as file:
        for line in file:
            pair = line.split('=', 1)
            try:
                if (len(pair) < 2):
                    # '=' is not found
                    continue
                service = shlex.split(pair[0], True)
                args = shlex.split(pair[1], True)
            except ValueError as ve:
                _debug('parse error: ' + line)
                if sys.version_info[0] > 2:
                    _debug(str(ve))
                else:
                    _debug(ve.message)
                continue

            if len(service) != 1:
                # the service name is not a single token.
                continue

            _debug('service: ' + service[0])
            _debug('arguments: ' + str(args))
            if service[0] in argsdict:
                argsdict[service[0]] += args
            else:
                argsdict[service[0]] = args
    return argsdict

def load_option_dirs(dirlist):
    '''Load options from specified directories'''
    _debug('load_option_dirs(%s)' % str(dirlist))
    retval = {}
    for d in dirlist:
        for conf in glob.glob(d + '/*.options'):
            load_option_file(conf, retval)
    return retval

### start-up routine
def start(ve_no, osbin, os_sock, options_dir):
    openlog(logoption = LOG_PID, facility = LOG_DAEMON)
    _debug(str(sys.argv))

    venode = VENode(ve_no, osbin, os_sock, options_dir)
    venode.start()

