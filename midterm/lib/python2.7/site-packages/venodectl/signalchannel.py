#!/usr/bin/python

# Copyright (C) 2017-2018 NEC Corporation
# This file is part of VE system initialization
#
# VE system initialization is free software; you can redistribute it and/or 
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# VE system initialization is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public
# License along with VE system initialization; if not, see
# <http://www.gnu.org/licenses/>
'''
Copyright (C) 2017-2018 NEC Corporation

Mechanism to receive signals via a pipe synchronously.
'''

import os
import sys
import signal
import select
import syslog
import fcntl
import struct
import errno
import ctypes

def no_log(msg):
  pass

class TimeSpec(ctypes.Structure):
  _fields_ = [('tv_sec', ctypes.c_long), # time_t is long.
              ('tv_nsec', ctypes.c_long)]

class SignalChannel(object):
  '''Signal channel object

  Attributes:
      channel: the read end of a pipe through which signal are sent
      debuglogger: a logger function with one argument for a message.
  '''
  def __init__(self, signals_to_catch, signals_to_catch_once=[], \
               debuglogger=no_log):
    '''Constructor.
       signals_to_catch: a collection of signals to catch
       signals_to_catch_once: a collection of signals.
           After receiving a signal, all signals in signals_to_catch_once
           are ignored.
       debuglogger: a logger function for debug log
    '''
    (pipe_r, pipe_w) = os.pipe()
    fcntl.fcntl(pipe_r, fcntl.F_SETFL, os.O_NONBLOCK)
    self.channel = pipe_r
    self.debuglogger = debuglogger

    # signal handler to send a signal number to pipe
    def send_sig_msg(signum, frame):
      debuglogger('receives signal %d' % signum)
      for s in signals_to_catch_once:
        debuglogger('signal %d is ignored from now.' % s)
        signal.signal(s, signal.SIG_IGN)
      os.write(pipe_w, struct.pack('I', signum))

    # register send_sig_msg as a signal handler
    for sig in signals_to_catch:
      signal.signal(sig, send_sig_msg)
    for sigo in signals_to_catch_once:
      signal.signal(sigo, send_sig_msg)

  def recv(self):
    '''Receive a single signal number from pipe

       recv() returns a signal number as integer.
       If no signal is put on pipe, raises OSError with EAGAIN.
    '''
    # self.channel is expected to be set to non-blocking mode.
    # os.read() never blocks and raises OSError with EAGAIN instead.
    data = os.read(self.channel, struct.calcsize('I'))
    # unpack() returns a tuple even on one item.
    sig = struct.unpack('I', data)[0]
    return sig

  def recv_all(self):
    '''Receive all signals caught and return a list of the signals.'''
    ret = []
    while True:
      try:
        sig = self.recv()
        ret.append(sig)
      except OSError as e:
        # no signal have been sent to the pipe.
        if sys.version_info[0] > 2:
          n_errno = e.errno
        else:
          n_errno = e[0]

        if n_errno == errno.EAGAIN:
          return ret
        else:
          raise

  # To implement _monotonic(), find clock_gettime() in libc.
  _libc = ctypes.CDLL('libc.so.6', use_errno=True)
  _clock_gettime = _libc.clock_gettime
  # defined in /usr/include/linux/time.h
  CLOCK_MONOTONIC = 1

  def _monotonic(self):
    '''Return the value of a motonic clock.

       This function is an alternative of time.monotonic() in Python 3.
    '''
    t = TimeSpec()
    if self._clock_gettime(self.CLOCK_MONOTONIC, ctypes.byref(t)) != 0:
      e = ctypes.get_errno()
      raise OSError(e, os.strerror(e))
    return t.tv_sec + t.tv_nsec / 1000000000.0

  def wait_for(self, sigs, timo=None):
    '''Wait for signals or time-out period.

       sigs: a collection of signals for which this function waits
       timo: a timeout in seconds (optional)
    '''

    remain = None
    start = self._monotonic()
    def update_remain():
      if timo is not None:
        remain = timo - (self._monotonic() - start)
      return remain

    remain = update_remain()

    while timo is None or remain > 0:
      self.debuglogger('timeout = ' + str(remain))
      try:
        (rlist, wlist, elist) = select.select([self], [], [], remain)
      except select.error as e:
        self.debuglogger('select is interrupted')
        if sys.version_info[0] > 2:
          n_errno= e.errno
        else:
          n_errno= e[0]

        if n_errno != errno.EINTR:
          raise

      sigs_recv = self.recv_all()
      self.debuglogger('received signal %s' % str(sigs_recv))

      for s in sigs:
        if s in sigs_recv:
          return True
      remain = update_remain()

    return False

  def fileno(self):
    return self.channel
