# Copyright (C) 2017-2018 NEC Corporation
# This file is part of VE system initialization
#
# VE system initialization is free software; you can redistribute it and/or 
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# VE system initialization is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public
# License along with VE system initialization; if not, see
# <http://www.gnu.org/licenses/>
'''
Copyright (C) 2017-2018 NEC Corporation

This module builds a list denoting a path to a VE device
from its DEVPATH.
'''

import fcntl
import io
import json
import os
import re
import sys
import syslog

MAX_VE_NODES = 8

def _bdfstr_to_tuple(bdfstr, domain_str):
    # This function extracts dd.f from dddd:bbbb:dd.f,
    # PCI BDF (Bus:Device.Function) string.
    result = re.match(domain_str + ':([0-9a-f]+):([0-9a-f]+)\\.([0-7])$', \
                      bdfstr)
    if not result:
        raise ValueError("unexpected : " + bdfstr)
    return result.group(1, 2, 3)

class VEDevPath(object):
    '''Path to VE node

    Attributes:
        _root: PCI domain and root bus number as string, e.g.
               "pci0000:00"
        _bdf: a list of tuples of bus, device and function number
                to the slot where VE node is connected.
        _devnum: device minor number
    '''

    def __init__(self, devpath):
        '''Builds from DEVPATH.

        Args:
             devpath: the devpath of the VE node, passed from udev
                      daemon as the DEVPATH environment variable.
        '''
        # DEVPATH is /devices/pci0000:00/.../ve/veN
        # extract 'N'
        self._devnum = int(devpath.partition('/ve/ve')[2])

        # bdflist = ['', 'devices', 'pci0000:??', ..., 've', 'veN']
        bdflist = devpath.split('/')
        # root bus information
        # capture domain number.
        match_domain = re.match('pci([0-9a-f]+):[0-9a-f]+$', bdflist[2])
        if not match_domain:
            raise ValueError("unexpected DEVPATH: " + devpath)
        # skip the substring "pci"
        self._root = bdflist[2][3:]

        domain_str = match_domain.group(1)
        domain = int(domain_str, base=16)
        # delete prefix ['', 'devices', 'pci0000:00']
        del bdflist[0:3]
        # delete suffix ['ve', 'veN']
        del bdflist[len(bdflist) - 2: len(bdflist)]
        # [('bb', 'dd', 'f'), ('bb', 'dd', 'f'), ...]
        self._bdf = [_bdfstr_to_tuple(x, domain_str) for x in bdflist]

    @property
    def pathstr(self):
        '''Return its string representation.'''
        # ('bb', 'dd', 'f') -> 'dd.f' for each element
        return self._root + '-' \
              + '-'.join([t[1] + '.' + t[2] for t in self._bdf])

    @property
    def devnum(self):
        return self._devnum

    @property
    def bdf(self):
        return ':'.join(self._bdf[-1])

def _add_new_device(conf, num, path, file):
    '''This function registers a new VE node,
       finding an unused node number.'''
    # find the lowest unused number
    unused_min = 0
    if sys.version_info[0] > 2:
        devnum_list = list(conf.values())
    else:
        devnum_list = conf.values()
    if not num in devnum_list:
        ret = num
    else:
        devnum_list.sort()
        for n in devnum_list:
            if n == unused_min:
                unused_min = unused_min + 1
            else:
                break
        ret = unused_min

    if unused_min >= MAX_VE_NODES:
        raise ValueError('cannot allocate a node number, fully used.')
    conf[path] = ret
    # save the devnum corresponding to the new device
    file.truncate(0)
    json.dump(conf, file)
    return ret

def get(devpath, conffile, datafile):
    ''' get VE node number.

    Args:
        devpath: /sys path of the VE node device.
        conffile: a static configuration file.
        datafile: a dynamic data file.

    Returns:
        A VE node number specified by devpath.
    '''

    ve = VEDevPath(devpath)
    pathstr = ve.pathstr
    kern_devnum = ve.devnum

    # use binary mode to avoid TypeError: must be unicode, not str.
    # search config file in sysconfdir
    try:
        with io.open(conffile, mode='rb') as f:
            # When a config file exists, any exceptions are not caught
            # in order that VE number issuer exits abnormally if a path name
            # corresponding to a device found is not found in the config
            # or the config is invalid format.
            conf = json.load(f)
            devnum = conf[pathstr]

    except KeyError as ke:
        # not found
        if sys.version_info[0] > 2:
            syslog.syslog(str(ke))
        else:
            syslog.syslog(ke.message)
        raise KeyError("VE node number for ve%d is not found.\n" \
                       % kern_devnum)

    except IOError:
        if sys.version_info[0] > 2:
            mode_s = 'a+'
        else:
            mode_s = 'a+b'

        with io.open(datafile, mode=mode_s) as f:
            fcntl.lockf(f, fcntl.LOCK_EX)
            # Append mode specified, the file pointer is at the end of the file
            f.seek(0, io.SEEK_SET)
            try:
                conf = json.load(f)
            except ValueError:
                # The file can be empty in the case of a file created at open.
                conf = {}
            try:
                devnum = conf[pathstr]
            except KeyError:
                devnum = _add_new_device(conf, kern_devnum, pathstr, f)
            # A lock is released at close as per POSIX.

    # check devnum is between 0 and MAX_VE_NODES - 1
    if devnum < 0 or MAX_VE_NODES <= devnum:
      raise ValueError('[%s] VE node #%d is out of bound' % (ve.bdf, devnum))
    syslog.syslog('veslot%d = %s' % (devnum, ve.bdf))
    return devnum

def main(devpath, conffile, datafile):
    try:
        print(get(devpath, conffile, datafile))
    except Exception as e:
        if sys.version_info[0] > 2:
            syslog.syslog(syslog.LOG_ERR, str(e))
        else:
            syslog.syslog(syslog.LOG_ERR, e.message)
        sys.exit(1)
